<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-kcyy.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-kcyy.jpg">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="baidu-site-verification" content="code-HeKMuEE69t">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta property="og:type" content="website">
<meta property="og:title" content="大琛的复活甲">
<meta property="og:url" content="http://example.com/home/index.html">
<meta property="og:site_name" content="大琛的复活甲">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="大琛的复活甲">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/home/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>大琛的复活甲</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">大琛的复活甲</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">大琛的复活甲</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="mailto:tojunfeng@qq.com" title="E-Mail → mailto:tojunfeng@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/05/hexo%E9%85%8D%E7%BD%AEmathjax/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大琛的复活甲">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大琛的复活甲">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/05/hexo%E9%85%8D%E7%BD%AEmathjax/" class="post-title-link" itemprop="url">hexo配置mathjax</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2021-02-05 08:11:45 / 修改时间：08:17:22" itemprop="dateCreated datePublished" datetime="2021-02-05T08:11:45+08:00">2021-02-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在 hexo 中，你会发现我们不能用 <code>Latex</code> 语法来书写数学公式，这对于书写学术博客来说是很大的不便，因为我们会经常碰到很多的数学公式推导，但是我们可以通过安装第三方库来解决这一问题。</p>
<h2 id="第一步：-使用Kramed代替-Marked"><a href="#第一步：-使用Kramed代替-Marked" class="headerlink" title="第一步： 使用Kramed代替 Marked"></a>第一步： 使用Kramed代替 Marked</h2><p><code>hexo</code> 默认的渲染引擎是 <code>marked</code>，但是 <code>marked</code> 不支持 <code>mathjax</code>。 <code>kramed</code> 是在 <code>marked</code> 的基础上进行修改。我们在工程目录下执行以下命令来安装 <code>kramed</code>.</p>
<pre class="line-numbers language-undefined" data-language="undefined"><code class="language-undefined">npm uninstall hexo-renderer-marked --save
npm install hexo-renderer-kramed --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后，更改your-project-dir/node_modules/hexo-renderer-kramed/lib/renderer.js，更改：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Change inline math rule</span>
<span class="token keyword">function</span> <span class="token function">formatText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// Fit kramed's rule: $$ + \1 + $$</span>
    <span class="token keyword">return</span> text<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">`\$(.*?)\$`</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token string">'$$$$$1$$$$'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为：</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token comment">// Change inline math rule</span>
<span class="token keyword">function</span> <span class="token function">formatText</span><span class="token punctuation">(</span><span class="token parameter">text</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> text<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="第二步-停止使用-hexo-math"><a href="#第二步-停止使用-hexo-math" class="headerlink" title="第二步: 停止使用 hexo-math"></a>第二步: 停止使用 hexo-math</h2><p>首先，如果你已经安装 <code>hexo-math</code>, 请卸载它：</p>
<pre class="line-numbers language-nodejs" data-language="nodejs"><code class="language-nodejs">npm uninstall hexo-math --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后安装 <a target="_blank" rel="noopener" href="https://github.com/phoenixcw/hexo-renderer-mathjax">hexo-renderer-mathjax</a> 包：</p>
<pre class="line-numbers language-npm" data-language="npm"><code class="language-npm">npm install hexo-renderer-mathjax --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="第三步-更新-Mathjax-的-CDN-链接"><a href="#第三步-更新-Mathjax-的-CDN-链接" class="headerlink" title="第三步: 更新 Mathjax 的 CDN 链接"></a>第三步: 更新 Mathjax 的 CDN 链接</h2><p>首先，打开path-to-your-project/node_modules/hexo-renderer-mathjax/mathjax.html</p>
<p>然后，把<code>&lt;script&gt;</code>更改为：</p>
<pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="第四步-更改默认转义规则"><a href="#第四步-更改默认转义规则" class="headerlink" title="第四步: 更改默认转义规则"></a>第四步: 更改默认转义规则</h2><p>因为 <code>hexo</code> 默认的转义规则会将一些字符进行转义，比如 <code>_</code> 转为 <code>&lt;em&gt;</code>, 所以我们需要对默认的规则进行修改.<br> 首先， 打开&lt;path-to-your-project/node_modules/kramed/lib/rules、inline.js,</p>
<p>然后，把:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">escape<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\\([\\`*&#123;&#125;\[\]()#$+\-.!_>])</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>更改为:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">escape<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\\([`*\[\]()# +\-.!_>])</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>把</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">em<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>更改为:</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">em<span class="token operator">:</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\*((?:\*\*|[\s\S])+?)\*(?!\*)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="第五步-开启mathjax"><a href="#第五步-开启mathjax" class="headerlink" title="第五步: 开启mathjax"></a>第五步: 开启mathjax</h2><p>在主题 <code>_config.yml</code> 中开启 Mathjax， 找到 <code>mathjax</code> 字段添加如下代码：</p>
<pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">mathjax:
    enable: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这一步可选，在博客中开启 <code>Mathjax</code>，， 添加以下内容：</p>
<pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown"><span class="token front-matter-block"><span class="token punctuation">---</span>
<span class="token font-matter yaml language-yaml">title: Testing Mathjax with Hexo
category: Uncategorized
date: 2017/05/03
mathjax: true</span>
<span class="token punctuation">---</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过以上步骤，我们就可以在 <code>hexo</code> 中使用 <code>Mathjax</code> 来书写数学公式。</p>
<p>转自：MaosongRan<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e8d433a2c5b7">https://www.jianshu.com/p/e8d433a2c5b7</a><br>来源：简书</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/02/04/%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%951/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大琛的复活甲">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大琛的复活甲">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/02/04/%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%951/" class="post-title-link" itemprop="url">分块算法1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-02-04 11:10:43" itemprop="dateCreated datePublished" datetime="2021-02-04T11:10:43+08:00">2021-02-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-08 16:01:36" itemprop="dateModified" datetime="2021-02-08T16:01:36+08:00">2021-02-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">根号算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><p>分块是一种易用性高、实现简单、单次操作时间复杂度为$O(\sqrt n)$的数据结构。</p>
<p>分块算法几乎可以解决所有线段树和平衡树能解决的问题。</p>
<h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><blockquote>
<p>对数列$\{a_n\}$有$n$次操作，分别为：</p>
<p>1、修改位置$pos$的值为给定的$val$（单点修改）</p>
<p>2、询问区间$[l,r]$的和（区间查询）</p>
<p>$1 \le n \le 10^5$</p>
</blockquote>
<p>这是一道经典的数据结构入门题。</p>
<p>简单分析按照题意的朴素算法的时间复杂度，对于单点修改操作每次为$O(1)$，对于区间查询每次操作的时间复杂度为$O(n)$。故最坏情况下时间复杂度为$O(n^2)$。显然这不能解决题目要求的数据范围。</p>
<p>根据上面的分析可以看到，时间复杂度的瓶颈是在查询过程。想要优化上面的算法，自然就要把重心放在<strong>优化查询</strong>的时间复杂度。</p>
<p>对于处理区间和问题，一个比较好的做法就是利用前缀做差，即数列的前缀和为$p_i$，那么区间$[l,r]$的和为$p_r-p_{l-1}$。而且通过$O(n)$的预处理所有前缀和后，单次的区间查询的时间复杂度就变成了$O(1)$了。这的确是一个非常巧妙的想法，而且也极大的提高了区间查询的时间复杂度。</p>
<p>但是预处理前缀和后，单点修改操作变得更加复杂了。每次单点修改后，为了维持前缀和信息，需要将单点修该的$pos$位置后面的所有前缀和信息进行更新，使得单点修改的时间复杂度为$O(n)$。这依然无法解决上面的问题。</p>
<h3 id="分块-1"><a href="#分块-1" class="headerlink" title="分块"></a>分块</h3><p>从上面的分析我们得到了两种修改-查询时间复杂度分别为$O(1)-O(n)$和$O(n)-O(1)$的算法。分块要做的事情正是在上面两种算法中寻找一个平衡点。</p>
<p>如何寻找这个平衡点呢？</p>
<p>假如我们把数列$\{a_n\}$前后均等的分成两个部分（两块），在这两个部分中分别（互不干扰的）应用前缀和的算法，可以发现对于单点修改操作就变为了$O(\frac{n}{2})$，而区间查询的时间复杂度变为$O(2)$（当查询区间横跨两块的时候）。</p>
<p><img src="https://gitee.com/tojunfeng/images/raw/master//img/fix-dir/myblog/post-images/2021-02-04-09-42-07-1591365873772.png" alt=""></p>
<p>同样的假如我们把数列$\{a_n\}$前后均等的分成$m$个块呢？对每个块都单独使用前缀和的算法，可以发现对于单点修改操作就变为了$O(\frac{n}{m})$，而区间查询的时间复杂度变为$O(m)$</p>
<p>现在问题我们就得到了很多个修改-查询时间复杂度为$O(\frac{n}{m})-O(m)$的算法。事实上我们发现其实一开始就直接得到的$O(1)-O(n)$的朴素算法就是一种分块的特殊情况（当$m=n$时）</p>
<p>如何确定$m$的值使得$\max\{\frac{n}{m},m\}$最小呢？最小为多少呢？这个$\max\{\frac{n}{m},m\}$就是算法的瓶颈。</p>
<p>当$m=\sqrt n$的时候得到$\max\{\frac{n}{m},m\}=\sqrt n$。即通过调节$m$的取值，可以用上述算法在$O(n\sqrt n)$内解决上面的问题。</p>
<blockquote>
<p>容易证明，当 $a*b=n$  且 $a,b \ge 0$时，$\max\{a,b\}$的最小值为$\sqrt n$。</p>
</blockquote>
<p>至此，我们就已经用分块算法在$O(n\sqrt n)$内解决了上面的问题。</p>
<h3 id="分块再分析"><a href="#分块再分析" class="headerlink" title="分块再分析"></a>分块再分析</h3><p>事实上上面我们得到的是 $O(\sqrt n)-O(\sqrt n)$算法。</p>
<p>分析上面的算法发现，每次查询的时候，对于$[l,r]$之间的那些整块（蓝色块）都是只需要查询块内元素的总和，只有边角信息（红色块）才需要做朴素算法那样的$p_j-p_i$进行查询。</p>
<p><img src="https://gitee.com/tojunfeng/images/raw/master//img/fix-dir/myblog/post-images/2021-02-04-09-42-01-1591365883862.png" alt=""></p>
<p>假如我们在每个块中再维护一个额外的信息——块内值的和，而不在维护块内的前缀和，会发送什么样的变化呢？</p>
<p>这种分块的方法对于修改操作来说时间复杂度将为了$O(1)$，而查询操作的时间复杂度为$O(\sqrt n)$（对于边角信息使用朴素算法扫描，也最多只会有$\sqrt n$个零散点），故修改-查询时间复杂度变为了$O(1)-O(\sqrt n)$。注这种算法的查询操作的常数比上面的查询操作要大。</p>
<p>通过上面的尝试，我们不禁会想，是否存在一种修改-查询时间复杂度$O(\sqrt n)-O(1)$的算法呢？答案是肯定的。我们只需要在修改-查询时间复杂度为$O(1)-O(\sqrt n)$的算法基础上记录一下块内和的前缀信息，再记录块内的前缀信息，就能使修改-查询时间复杂度$O(\sqrt n)-O(1)$。</p>
<blockquote>
<p>其实想要得到修改-查询时间复杂度$O(\sqrt n)-O(1)$的做法也可以不使用辅助空间，直接让第$i$块内的最后一个元素记录前$i$个块的前缀和即可。</p>
</blockquote>
<p>在很多情况下，我们除了要应对分块带来的时间开销，还需要去计算其他信息，这时候我们就可以根据实际情况选择修改-查询时间复杂度为$O(1)-O(\sqrt n)$的算法或者修改-查询时间复杂度$O(\sqrt n)-O(1)$的算法。</p>
<h3 id="不均等分块"><a href="#不均等分块" class="headerlink" title="不均等分块"></a>不均等分块</h3><p>除了上述的均等分的分块算法，当然还有不均等分的分块算法。</p>
<p>例如树状数组可以看着一个按照二进制位进行分块的算法，这样使得单点修改和前缀和查询的时间复杂度变为了$O(\log n)-O(\log n)$。</p>
<p>除此之外，还有按照十进制进行分块的算法:</p>
<p>使得修改-查询时间复杂度为$O(\log_{10}n)-O(\log_{10}{9*n})$</p>
<p>或者修改-查询时间复杂度为$O(\log_{10}{9*n})-O(\log_{10}n)$。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/02/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大琛的复活甲">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大琛的复活甲">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/02/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89/" class="post-title-link" itemprop="url">莫队算法（2）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-02 10:38:37" itemprop="dateCreated datePublished" datetime="2020-06-02T10:38:37+08:00">2020-06-02</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-08 16:02:15" itemprop="dateModified" datetime="2021-02-08T16:02:15+08:00">2021-02-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">根号算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本节主要针对普通的莫队算法给出一些应用</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.spoj.com/problems/DQUERY/">DQUERY - D-query</a></p>
<p>对于给定的数列$\{a_n\}$，有$q$次询问，每次询问区间$[l,r]$中不同的数的个数</p>
<p>$1\le n,q \le 10^5$</p>
</blockquote>
<p>这是一道莫队的模板题，也是上一节用到的例题。通过离线算法主要有$n\sqrt n$的莫队和$n\log n$的树状数组两种做法，在线查询的话可以用$n\log n$的主席树维护。</p>
<p>此处笔者想要强调的是莫队算法中排序时的一种普遍的优化——分奇偶排序。一般情况下，奇偶优化能够使得程序运行时间缩短至未优化时的一半。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">QQ</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>id<span class="token punctuation">;</span>
	<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">const</span> QQ<span class="token operator">&amp;</span> tmp<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">/</span>BLOCK<span class="token operator">==</span>tmp<span class="token punctuation">.</span>l<span class="token operator">/</span>BLOCK<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//奇偶块的右端点升降交替排序</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l<span class="token operator">/</span>BLOCK<span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> r<span class="token operator">&lt;</span>tmp<span class="token punctuation">.</span>r<span class="token punctuation">;</span> <span class="token comment">//偶数块升序</span>
			<span class="token keyword">else</span> <span class="token keyword">return</span> r<span class="token operator">></span>tmp<span class="token punctuation">.</span>r<span class="token punctuation">;</span> <span class="token comment">//奇数块降序</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> l<span class="token operator">&lt;</span>tmp<span class="token punctuation">.</span>l<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>q<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3604">洛谷P3604 美好的每一天</a></p>
<p>对于给定的字符串$s$，有$q$次询问，每次询问区间$s_l \cdots s_r$组成的字符串中有多少个字串经过重排后可以组成一个回文串</p>
<p>示例：</p>
<p>输入<br>zzqzzq<br>1 6<br>2 4<br>1 1<br>输出<br>16<br>4<br>1</p>
</blockquote>
<p>先剖析问题的本质，字符串重排后能够组成回文串，也就是说，</p>
<ul>
<li>对于字符串长度为偶数时，每个字母出现的次数都为偶数次</li>
<li>对于字符串长度为奇数时，最多只有一个字母，出现的字符串长度为奇数次</li>
</ul>
<p>问题就转换为，询问一个字符串中有多少个字串，其最多只有一个字母数出现的次数为奇数。</p>
<p>我们就有一个比较显然的策略就是，对于每个查询区间，我们暴力遍历它的每一个字串，然后判断该字串有多少个字母出现次数小于等于1。于是我们就得到了一个$O(n^3)$的算法。</p>
<p>显然我们可以通过按照莫队算法的方式对询问进行离线组织，这样的话还是按照上述的暴力更新每次移动左右端点时答案的变化，我们可以得到一个$O(n^2\sqrt n)$的算法。这还是不够。</p>
<p>事实上，我们统计的是每种字母出现的次数，而我们只关心每种字母出现次数的奇偶性，而且字母种类只有26种，那么我们是否可以根据这两点进行优化呢？</p>
<p>答案是肯定的。</p>
<p>根据上面的分析，我们只想要这个串的部分信息，那么每一个任意长度的字符串都是可以通过一个26位的二进制串来表示的，二进制串的第$i$位就表示原字符串中字母$a+i$出现次数的奇偶性。</p>
<p>进一步的分析发现，对于题目给出的原串$s$我们自需要求出它所有前缀的二进制表示$pre_i$就能得到原串所有子串的二进制表示（对于任意个子串$s_l \cdots s_r$，它的二进制表示为 $pre_r \bigoplus pre_{l-1} $ ）</p>
<p>分析到此，我们就可以考虑如何让快速的从$[l,r]$更新到$[l,r+1]$了。每次增加一个右端点进来，就去查看对于该右端点，区间内有多少个左端点与之组合能够对答案产生贡献。这个过程只需要枚举所有能够产生贡献的那27种最终状态（$0 \bigcup 2^i,0 \le i\le 26$）反向计算，那些左端点的$pre_i$应该满足什么样的条件。就能快速得到答案。</p>
<p>问题的时间复杂度为$O(26n\sqrt n)$。</p>
<hr>
<p><strong>时间复杂度再分析</strong></p>
<p>对于莫队算法，主要需要考虑两个问题</p>
<ul>
<li>一是移动左右端点的时候，相关信息的维护，一般要求是在$O(1)$，有时$O(\log n)$也可以</li>
<li>二是当左右端点确定后如何统计答案，这一步的时间复杂度需要做到$O(\sqrt n)$或者$O(\sqrt n \log n)$</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/940/F">CF940F Machine Learning</a>的简化版（原题要求单点修改）</p>
<p>给你一个数组$\{a_n\}$，每次询问区间$[l,r]$每个数字出现次数的$mex$</p>
<p>$mex$指的是一些数字中最小的未出现的自然数。值得注意的是，区间$[l,r]$总有数字是没有出现过的，所以答案不可能为0。</p>
<p>例如：对于数列$\{100,23,5,7,7,7\}$，其中有无穷多个数出现了$0$次，有三个数出现了$1$次，有一个数出现了$3$次。所以这个数列每个数出现次数的$mex$是$2$（没有哪一个数出现了$2$次，其$2$是最小的）</p>
</blockquote>
<p>最直接的想法就是暴力统计每个查询区间的数出现了多少次，然后依次扫描寻找没有任何数字出现了$ans$次。</p>
<p>单次统计区间信息需要$O(n)$，可以确定的是答案一定不会超过$\sqrt n$，即每次扫描的时间复杂度为$O(\sqrt n)$。故总的时间复杂度为$O(n^2)$。</p>
<p>利用莫队算法，每次移动左右端点的时间复杂度为$O(1)$，需要移动$O(n\sqrt n)$次端点。每次询问答案的时间复杂度为$O(\sqrt n)$，共需要询问$O(n)$次答案。故莫队算法总的的时间复杂度为$O(n\sqrt n)$。</p>
<hr>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://codeforces.com/problemset/problem/1000/F">CF1000F One Occurrence</a></p>
<p>给定一个长度为$n$的序列$\{a_n\}$，$m$次询问，每次询问给定一个区间$[l,r]$，如果这个区间里存在只出现一次的数，输出这个数（如果有多个就输出任意一个），没有就输出$0$。</p>
<p>$n,m \le5*10^5$</p>
</blockquote>
<p>使用莫队的时候发现某个数字是第一次出现，就把当前数字加入到$ans$数组中，如果某个数字是第二次出现，就需要将那个数字从$ans$数组中删除，关键是出现了删除操作，使得问题变得更加复杂了。</p>
<p>如果我们使用平衡树来代替$ans$数组，插入和删除的时间复杂度均为$O(\log n)$那么总的时间复杂度为$O(n\sqrt n\log n)$。显然这个时间复杂度无法在规定的时间内给出答案。</p>
<p>根据上面我们所做出的分析，我们可以像线段树一样使用一种懒操作，即对删除操作打标记。维护一个栈，当一个元素不在栈中的时候，那他一定不在$ans$数组里面。当我们要删除某个元素的时候，只需要标记一下栈中的某个元素已被删除，即时它仍然在栈中。</p>
<p>那么每次询问答案的时候就依次访问栈内的元素，如果元素无效将其出栈，否则输出该元素。</p>
<p>上面的懒删除操作的准正确性是显然的。但是时间复杂度是多少呢？</p>
<p>对于每次区间移动时间开销显然是$O(1)$的，但是每次的答案统计的时间复杂度呢？每个数的只会在区间移动的时候进栈，也就是最多只有$O(n\sqrt n)$次进栈操作，而每次统计答案的时候都是出栈操作，故统计答案的总的操作数也是$O(n\sqrt n)$级别的。</p>
<p>综上，时间复杂度为$O(n\sqrt n)$。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/31/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大琛的复活甲">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大琛的复活甲">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/31/%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89/" class="post-title-link" itemprop="url">莫队算法（1）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-31 20:22:03" itemprop="dateCreated datePublished" datetime="2020-05-31T20:22:03+08:00">2020-05-31</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-08 16:02:06" itemprop="dateModified" datetime="2021-02-08T16:02:06+08:00">2021-02-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%A0%B9%E5%8F%B7%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">根号算法</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="莫队算法"><a href="#莫队算法" class="headerlink" title="莫队算法"></a>莫队算法</h4><p>莫队算法主要用于解决<strong>离线的区间问题</strong>。一般来说时间复杂度为$O(n\sqrt n)$，对于带修改的莫队算法时间复杂度一般为$O(n^{5/3})$。</p>
<h4 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h4><p>考虑这样一个问题：</p>
<blockquote>
<p>对于数列 ${a_n}$ 有 $n$ 次询问，每次询问区间 $[l,r]$ 中不同的数的个数。</p>
<p>$n \le 100000$   ,  $1\le l \le r \le 100000$</p>
</blockquote>
<p>一个很显然的想法是，对于每一个询问我们从左到右遍历一遍 $a$ 数组，用另一个数组维护每个数字是否出现，这样就能得到每次询问的答案。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">100001</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> a<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span>cnt<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">ask</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//初始化cnt数组</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> ret<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//第一次出现</span>
        cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是我们这样的算法肯定无法在规定的时间内计算出所有的答案。</p>
<p>分析上述算法，我们发现我们是把每次查询都孤立开来看的。</p>
<p>事实上，假如对于两次相同的询问，我们完全可以利用上一次得到的答案，而省掉一次调用ask函数的时间开销。还有一个显然的问题就是，$n$ 次查询中可能没有两个询问的区间是一模一样的。</p>
<p>即便如此，上面的思考仍然会带给我们一些启发。退而求其次，如果两个询问比较接近，那么我们依然可以借用上一次的询问得到的信息来<strong>加速</strong>这次询问的查询效率。</p>
<p>例如：$[l_i,r_i]$ 为本次查询的区间，那么下一次询问的区间 $[l_{i+1},r_{i+1}]$ 如何利用 $[l_i,r_i]$ 的信息来加速呢？假如 $l_{i+1} \le l_i \le r_i \le r_{i+1} $ ，对于 $[l_{i+1},r_{i+1}]$ 的查询的ask函数就可以完全保留cnt数组，然后循环遍历 $l_{i+1}-&gt;l_i$ 和  $r_i-&gt;r_{i+1}$ 。</p>
<p>对于其他诸如 $l_i \le l_{i+1}$ 的时候，同样可以借助 $[l_i,r_i]$ 的信息，只是cnt的数组的初始化部分更新一下。</p>
<p>于是我们就可以写出一个优化的ask函数如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">ask</span><span class="token punctuation">(</span><span class="token keyword">int</span> lastL<span class="token punctuation">,</span><span class="token keyword">int</span> lastR<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">,</span><span class="token keyword">int</span> lastAns<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">//cnt数组共用</span>
    <span class="token keyword">int</span> ret<span class="token operator">=</span>lastAns<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>lastL<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//左边上次未计算的区间贡献答案</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>l<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>lastL<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> ret<span class="token operator">++</span><span class="token punctuation">;</span> 
            cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>l<span class="token operator">></span>lastL<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//如果左边计算得多了，得将多余区间贡献的答案减掉，并还原cnt数组</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>lastL<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>l<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> ret<span class="token operator">--</span><span class="token punctuation">;</span>
            cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token operator">></span>lastR<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">//右边同理</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>lastR<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>r<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> ret<span class="token operator">++</span><span class="token punctuation">;</span>
            cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>r<span class="token operator">&lt;</span>lastR<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>lastR<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> ret<span class="token operator">--</span><span class="token punctuation">;</span>
            cnt<span class="token punctuation">[</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到此，我们就基本掌握了莫队算法的核心了，但是还有一个非常重要的问题还没有解决，那就是就算每次我们都在上次询问答案的基础上进行进一步的加工，那么我们的时间复杂度究竟改进了多少？</p>
<h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>根据上述算法，很容易知道总的操作次数</p>
<p>从  $\sum_{i=1}^n (r_i-l_i+1)$  变为了  $(r_1-l_1+1)+\sum_{i=2}^n \vert l_i-l_{i-1} \vert + \vert r_i-r_{i-1} \vert$ </p>
<p> 很遗憾的是，我们这种优化并没有从本质上改变时间复杂度，即时间复杂度还是 $O(n^2)$ 的。例如给出的查询数据如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token number">1</span> <span class="token number">100000</span>
<span class="token number">50000</span> <span class="token number">50000</span>
<span class="token number">1</span> <span class="token number">100000</span>
<span class="token number">50000</span> <span class="token number">50000</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但是，如果我们通过合理的调整查询的顺序，是否可以改善时间复杂度呢？</p>
<p>答案是肯定的。</p>
<p>对于每一查询 $[l_i,r_i]$ 我们把它看作是二维平面中坐标为 $(l_i,r_i)$ 的点，那么 $\vert l_i-l_{i-1} \vert + \vert r_i-r_{i-1} \vert$ 即为两点之间的<strong>曼哈顿距离</strong>。$n$个查询区间看作$n$个二维平面的点的话，那么我们的查询顺序不就是连接这$n$个点的那$n-1$条边吗？</p>
<p>那我们的查询顺序不就可以抽象成在这 $n$个点，$\frac{n*(n-1)}{2}$ 边，边权为两点之间的曼哈顿距离，组成的完全图中找出一条路径，使得$n$个点都在此路径上，且这条路径的边权和最小，或者尽量小。</p>
<blockquote>
<p>其实也不用是路径。只要是能把这$n$个点完全覆盖就行。</p>
<p>也就是说，要寻找的其实就是<strong>曼哈顿最小生成树</strong>。</p>
<p>已知曼哈顿最小生成树的边权和是不超过$n\sqrt{n}$ 的</p>
<blockquote>
<p>曼哈顿最小生成树也可在$O(n\log{n})$求出。</p>
</blockquote>
<p>其实并不需要求出最小曼哈顿生成树</p>
</blockquote>
<p>如何<strong>简单且高效</strong>的找出这条路径呢？这又是莫队算法另一个精妙之处。</p>
<p>莫队算法给出了一种构造方案，可以使得这条路径的边权和在$O(n\sqrt{n})$级别。</p>
<p>构造方案：</p>
<ul>
<li>确定一个常数 $block$ 。（通常情况下 $block=\sqrt{n}$ ）</li>
<li>对所有区间进行排序，排序的比较规则如下：<ul>
<li>如果 $\frac{l_i}{block}=\frac{l_j}{block}$<ul>
<li>按照右端点 $r$ 升序排序</li>
</ul>
</li>
<li>否则<ul>
<li>按照左端点升序排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>事实上，这种构造方案相当于将所有的区间分成了 $\frac{n}{block}$ 个块</p>
<p>我们还是将每个区间看作二维平面的点，那么这个示意图如下：<br><img src="https://gitee.com/tojunfeng/images/raw/master//img/fix-dir/myblog/post-images/2021-02-04-09-41-18-1590936967733.png" alt="示例图" style="zoom: 33%;" /></p>
<p>蓝色线中的点表示同一个块中的点之间的转移排序顺序，而紫色的线表示不同块之间的转移顺序。</p>
<p>容易证明，紫色的线只有$\frac{n}{block}=\sqrt n$条（我们先默认$block=\sqrt n$ ），而每条紫线的x坐标之差不超过$\sqrt n$，y坐标之差不超过$n$。故紫线所用的所有开销为$O(n\sqrt n)$。</p>
<p>蓝色的线最多有$n-1$条。每条蓝色的线的x坐标之差不超过$block = \sqrt n$ 。而在单个块中累积的y坐标之差之和不超过$n$。故蓝线所有的开销为$O(n\sqrt n)$。</p>
<p>一开始对区间进行排序的时间复杂度为$O(n\log n)$</p>
<p>综上，莫队总的时间复杂度为$O(n\log n+n\sqrt n)$</p>
<p><a href="../mo-dui-suan-fa-2">莫队算法的应用</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/05/13/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8Cn%E7%9A%84%E5%85%B3%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大琛的复活甲">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大琛的复活甲">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/05/13/%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8Cn%E7%9A%84%E5%85%B3%E7%B3%BB/" class="post-title-link" itemprop="url">约数个数和n的关系</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-13 22:30:56" itemprop="dateCreated datePublished" datetime="2020-05-13T22:30:56+08:00">2020-05-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-06 18:11:25" itemprop="dateModified" datetime="2021-02-06T18:11:25+08:00">2021-02-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>求</p>
<script type="math/tex; mode=display">
cnt=\sum_{i=1}^{n}1_{num(i)\leq t*log_2^n}</script><p>其中$num(i)$为数 $i$ 的约数的个数，$t$ 为常数。</p>
<script type="math/tex; mode=display">
num（n）\leq (log_2^n)^2</script><p>结论发现  $10^6$ 范围的数全部满足上述公式， $10^8$ 范围的数只有 $33$ 个不满足上述公式。</p>
<p>$n=10^5$ 时</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">t</th>
<th style="text-align:center">cnt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">24387</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">6620</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">2172</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">699</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">214</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">54</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>$n=10^6$ 时</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">t</th>
<th style="text-align:center">cnt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">6310</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">2162</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">1047</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">353</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">152</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">93</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">19</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>$n=10^7$ 时</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">t</th>
<th style="text-align:center">cnt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">3391</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">1766</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">1009</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">692</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">250</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">137</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">70</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">29</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>$n=10^8$ 时</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">t</th>
<th style="text-align:center">cnt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">69268</td>
</tr>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">53934</td>
</tr>
<tr>
<td style="text-align:center">12</td>
<td style="text-align:center">27657</td>
</tr>
<tr>
<td style="text-align:center">13</td>
<td style="text-align:center">18302</td>
</tr>
<tr>
<td style="text-align:center">14</td>
<td style="text-align:center">13410</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">8455</td>
</tr>
<tr>
<td style="text-align:center">16</td>
<td style="text-align:center">4953</td>
</tr>
<tr>
<td style="text-align:center">17</td>
<td style="text-align:center">3695</td>
</tr>
<tr>
<td style="text-align:center">18</td>
<td style="text-align:center">2413</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">1679</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">858</td>
</tr>
<tr>
<td style="text-align:center">21</td>
<td style="text-align:center">515</td>
</tr>
<tr>
<td style="text-align:center">23</td>
<td style="text-align:center">260</td>
</tr>
<tr>
<td style="text-align:center">24</td>
<td style="text-align:center">110</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center">62</td>
</tr>
<tr>
<td style="text-align:center">26</td>
<td style="text-align:center">27</td>
</tr>
<tr>
<td style="text-align:center">27</td>
<td style="text-align:center">19</td>
</tr>
<tr>
<td style="text-align:center">28</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">29</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> MAXN<span class="token operator">=</span><span class="token number">1e5</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> times<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> prime<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">get_di</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	num<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>MAXN<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			prime<span class="token punctuation">[</span><span class="token operator">++</span>prime<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>i<span class="token punctuation">;</span>
			num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
			d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>prime<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&amp;&amp;</span>i<span class="token operator">&lt;</span>MAXN<span class="token operator">/</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			prime<span class="token punctuation">[</span>i<span class="token operator">*</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
				d<span class="token punctuation">[</span>i<span class="token operator">*</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
				num<span class="token punctuation">[</span>i<span class="token operator">*</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">/</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			num<span class="token punctuation">[</span>i<span class="token operator">*</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
			d<span class="token punctuation">[</span>i<span class="token operator">*</span>prime<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>MAXN<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> prime<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">get_di</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> cnt<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>MAXN<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span>times<span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
			cnt<span class="token operator">++</span><span class="token punctuation">;</span>
			<span class="token comment">// printf("%d %d\n", num[i],i);</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/02/04/%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="大琛的复活甲">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大琛的复活甲">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/02/04/%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91/" class="post-title-link" itemprop="url">最小割树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-02-04 11:10:43" itemprop="dateCreated datePublished" datetime="2020-02-04T11:10:43+08:00">2020-02-04</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-02-08 20:55:34" itemprop="dateModified" datetime="2021-02-08T20:55:34+08:00">2021-02-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BD%91%E7%BB%9C%E6%B5%81/" itemprop="url" rel="index"><span itemprop="name">网络流</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>$G=(V,E)$表示一个无向图，$c(e)$表示该无向图的边权</p>
<p>一个<strong>割</strong>是将点集$V$划分为两个集合$S$和$T$的划分</p>
<p>任何一条边$(u,v)\in E$。若$u\in S,v\in T$，那就说这条边为<strong>割边</strong></p>
<p>一个<strong>割的容量</strong>就是所有割边的边权和</p>
<p><img src="https://gitee.com/tojunfeng/images/raw/master//img/image-20210208181522373.png" alt="image-20210208181522373" style="zoom: 25%;" /></p>
<p>$u-v \space cut$ 是一个$u\in S, v\in T$ 的割</p>
<p>最小$u-v \space cut$是指边权和最小的$u-v \space cut$，这个边权和用$C_{u,v}$表示</p>
<p>$T=(V,F)$为$G=(V,E)$的<strong>最小割树</strong>需满足：</p>
<ul>
<li>树上任意一条边$(u,v)$的边权为图$G$中$u,v$两点的最小割。断开这条边后分成的两个连通块恰好对应原图最小割的$(S,T)$两个点集</li>
</ul>
<h4 id="最小割树的构造"><a href="#最小割树的构造" class="headerlink" title="最小割树的构造"></a>最小割树的构造</h4><ul>
<li>初始时$T=(V,F)$，$V$为所有的点集，$F=\emptyset$</li>
<li>任选两点$u,v$，在$G$中得到两点的最小割$C_{u,v}$，将边$(u,v,C_{u,v})$加入$F$集合中</li>
<li>得到上述割的$S,T$集合</li>
<li>对$S,T$集合重复执行第二步操作，知道集合大小为1</li>
</ul>
<p><img src="https://gitee.com/tojunfeng/images/raw/master//img/image-20210208184613668.png" alt="示意图"></p>
<h5 id="这种构造的做法能否得到最小割树的正确性证明："><a href="#这种构造的做法能否得到最小割树的正确性证明：" class="headerlink" title="这种构造的做法能否得到最小割树的正确性证明："></a>这种构造的做法能否得到最小割树的正确性证明：</h5><p>设在选择第一对点$(s,t)$的时候得到的最小割为$(S,T)$</p>
<p>第二次在$S$点集中任意选的两点为$(u,v)$得到的最小割为$(U,V)$</p>
<p>现在目标要证：$T \subseteq U \space or \space T \subseteq V$</p>
<p><img src="https://gitee.com/tojunfeng/images/raw/master//img/image-20210208203737031.png" alt="image-20210208203737031" style="zoom:50%;" /></p>
<p>显然X部分割的边的容量不大于Y部分割的边的容量，否则与$(S,T)$是$(s,t)$的最小割矛盾</p>
<p>证毕。</p>
<h4 id="任意两点的最小割等于最小割树上两点路径上的最小边权"><a href="#任意两点的最小割等于最小割树上两点路径上的最小边权" class="headerlink" title="任意两点的最小割等于最小割树上两点路径上的最小边权"></a>任意两点的最小割等于最小割树上两点路径上的最小边权</h4><p>引理：对于任意一个无向图的三个点$u,v,w$有，$C_{u,v} \ge \min\{C_{u,w},C_{w,v}\}$</p>
<p>证：若$(U,V)$为$(u,v)$的最小割，设$w\in U$（$w\in V$同理）必有 $C_{u,v} \ge C_{w,v}$</p>
<p>推广：对于点集$a_1,\cdots,a_n$有$C_{a_1,a_n} \ge \min\{C_{a_1,a_2},\cdots,C_{a_{n-1},a_n} \}$</p>
<p>由上述引理可知，原图任意两点的最小割一定大于等于最小割树上最两点路径上的最小边权</p>
<p>引理：设$(u,v)$的最小割$(U,V)$，任意点对$(x,y)$，若$x\in U,y\in V$有$C_{x,y} \le C_{u,v}$</p>
<p>由上述引理可知，原图任意两点的最小割一定小于等于最小割树上最两点路径上的最小边权</p>
<p>综上：原图任意两点的最小割一定大于等于最小割树上最两点路径上的最小边权</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>






<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大琛的复活甲</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>


  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.0.0/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink.listen({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'http://example.com/home/',]
      });
      });
  </script>

</body>
</html>
